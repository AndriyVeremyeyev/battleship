[{"/home/averemyeyev/andriy/projects/battleship/src/index.tsx":"1","/home/averemyeyev/andriy/projects/battleship/src/store.ts":"2","/home/averemyeyev/andriy/projects/battleship/src/App.tsx":"3","/home/averemyeyev/andriy/projects/battleship/src/GameController.tsx":"4","/home/averemyeyev/andriy/projects/battleship/src/reducers/index.ts":"5","/home/averemyeyev/andriy/projects/battleship/src/database.ts":"6","/home/averemyeyev/andriy/projects/battleship/src/Firewall.tsx":"7","/home/averemyeyev/andriy/projects/battleship/src/EnterName.tsx":"8","/home/averemyeyev/andriy/projects/battleship/src/StartGame.tsx":"9","/home/averemyeyev/andriy/projects/battleship/src/Header.tsx":"10","/home/averemyeyev/andriy/projects/battleship/src/Battle.tsx":"11","/home/averemyeyev/andriy/projects/battleship/src/strings.ts":"12","/home/averemyeyev/andriy/projects/battleship/src/actions/index.ts":"13","/home/averemyeyev/andriy/projects/battleship/src/PlayAgain.tsx":"14","/home/averemyeyev/andriy/projects/battleship/src/Legend.tsx":"15","/home/averemyeyev/andriy/projects/battleship/src/Field.tsx":"16","/home/averemyeyev/andriy/projects/battleship/src/components/CustomButton.tsx":"17"},{"size":509,"mtime":1621535294443,"results":"18","hashOfConfig":"19"},{"size":137,"mtime":1620679181954,"results":"20","hashOfConfig":"19"},{"size":710,"mtime":1622070580593,"results":"21","hashOfConfig":"19"},{"size":915,"mtime":1621535294443,"results":"22","hashOfConfig":"19"},{"size":7148,"mtime":1621989938825,"results":"23","hashOfConfig":"19"},{"size":1156,"mtime":1621458121680,"results":"24","hashOfConfig":"19"},{"size":365,"mtime":1621535294443,"results":"25","hashOfConfig":"19"},{"size":2363,"mtime":1621989420277,"results":"26","hashOfConfig":"19"},{"size":1689,"mtime":1621535294443,"results":"27","hashOfConfig":"19"},{"size":1343,"mtime":1621474706181,"results":"28","hashOfConfig":"19"},{"size":34369,"mtime":1622069800944,"results":"29","hashOfConfig":"19"},{"size":2013,"mtime":1621537512522,"results":"30","hashOfConfig":"19"},{"size":3114,"mtime":1621476346255,"results":"31","hashOfConfig":"19"},{"size":1812,"mtime":1621543555335,"results":"32","hashOfConfig":"19"},{"size":2509,"mtime":1621980106211,"results":"33","hashOfConfig":"19"},{"size":3942,"mtime":1622070675137,"results":"34","hashOfConfig":"19"},{"size":507,"mtime":1622070003896,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},"uu5yiq",{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"38"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/averemyeyev/andriy/projects/battleship/src/index.tsx",[],["72","73"],"/home/averemyeyev/andriy/projects/battleship/src/store.ts",[],"/home/averemyeyev/andriy/projects/battleship/src/App.tsx",[],"/home/averemyeyev/andriy/projects/battleship/src/GameController.tsx",[],"/home/averemyeyev/andriy/projects/battleship/src/reducers/index.ts",[],"/home/averemyeyev/andriy/projects/battleship/src/database.ts",[],"/home/averemyeyev/andriy/projects/battleship/src/Firewall.tsx",[],"/home/averemyeyev/andriy/projects/battleship/src/EnterName.tsx",[],"/home/averemyeyev/andriy/projects/battleship/src/StartGame.tsx",[],"/home/averemyeyev/andriy/projects/battleship/src/Header.tsx",[],"/home/averemyeyev/andriy/projects/battleship/src/Battle.tsx",["74","75","76","77","78"],"import React, { useState, useEffect, Fragment } from \"react\";\nimport { connect } from \"react-redux\";\nimport { Grid, Typography, Button, TextField, Modal } from \"@material-ui/core\";\nimport Field from \"./Field\";\nimport PlayAgain from \"./PlayAgain\";\nimport Legend from \"./Legend\";\nimport {\n  setShip,\n  setShipsCells,\n  setShipsShadowsCells,\n  setLegendLineOne,\n  setLegendLineTwo,\n  setShipsStatus,\n  setWrongAttempts,\n  setAttempts,\n  setShowComputer,\n  setKilledCells,\n  removeShipCell,\n  setPossibleDirections,\n  removePossibleDirections,\n  setShipsCellsTotal,\n  setShipsShadowsCellsTotal,\n  removeShadows,\n  setPlayAgain,\n  setFirstTime,\n  clearEverything,\n  setDamagedShip,\n  setIsBattle,\n  setScore,\n} from \"./actions/index\";\nimport {\n  rows,\n  columns,\n  shipNames,\n  direction,\n  shipLengths,\n  shipNicknames,\n  generateFreeCells,\n} from \"./database\";\nimport strings from \"./strings\";\nimport {\n  TypeOneAction,\n  TypeTwoAction,\n  TypeThreeAction,\n  TypeFourAction,\n  TypeFiveAction,\n  TypeSixAction,\n  TypeSevenAction,\n  TypeEightAction,\n  TypeNineAction,\n  TypeTenAction,\n} from \"./types\";\nimport CustomButton from \"./components/CustomButton\";\n\ntype BattleProps = {\n  setShip: (player: string, ship: string, position: string[]) => TypeTenAction;\n  setShipsCells: (player: string, cell: string) => TypeSixAction;\n  setShipsShadowsCells: (player: string, cell: string) => TypeSixAction;\n  computer: any;\n  setLegendLineOne: (legend: string) => TypeThreeAction;\n  setLegendLineTwo: (legend: string) => TypeThreeAction;\n  player: any;\n  setShipsStatus: (\n    player: string,\n    ship: string,\n    status: boolean\n  ) => TypeEightAction;\n  setShowComputer: () => TypeOneAction;\n  showComputer: boolean;\n  setKilledCells: (player: string, cell: string) => TypeSixAction;\n  removeShipCell: (\n    player: string,\n    ship: string,\n    cell: string\n  ) => TypeNineAction;\n  setWrongAttempts: (player: string, atempt: string) => TypeSixAction;\n  setPossibleDirections: (cell: string) => TypeThreeAction;\n  removePossibleDirections: () => TypeOneAction;\n  setAttempts: (player: string) => TypeThreeAction;\n  setShipsCellsTotal: (obj: any) => TypeFiveAction;\n  setShipsShadowsCellsTotal: (player: string, obj: any) => TypeSevenAction;\n  removeShadows: () => TypeOneAction;\n  setPlayAgain: (status: boolean) => TypeTwoAction;\n  playAgain: boolean;\n  setFirstTime: (status: boolean) => TypeTwoAction;\n  firstTime: boolean;\n  clearEverything: () => TypeOneAction;\n  setDamagedShip: (ship: string[]) => TypeFourAction;\n  setIsBattle: (status: boolean) => TypeTwoAction;\n  isBattle: boolean;\n  setScore: (side: string) => TypeThreeAction;\n  score: number[];\n  playerName: string;\n};\n\n// const useStyles = makeStyles({\n// });\n\nconst Battle: React.FC<BattleProps> = (props) => {\n  // to generate computer map once battle is mounted\n\n  // const classes = useStyles();\n\n  const {\n    setShip,\n    setShipsCells,\n    setShipsShadowsCells,\n    computer,\n    setLegendLineOne,\n    setLegendLineTwo,\n    player,\n    setShipsStatus,\n    setShowComputer,\n    showComputer,\n    setKilledCells,\n    removeShipCell,\n    setWrongAttempts,\n    setPossibleDirections,\n    removePossibleDirections,\n    setAttempts,\n    setShipsCellsTotal,\n    setShipsShadowsCellsTotal,\n    removeShadows,\n    setPlayAgain,\n    playAgain,\n    setFirstTime,\n    firstTime,\n    clearEverything,\n    setDamagedShip,\n    setIsBattle,\n    isBattle,\n    setScore,\n    score,\n    playerName,\n  } = props;\n  const [firstRender, setFirstRender] = useState(false);\n  const [open, setOpen] = useState(false);\n  const [playerTurn, setPlayerTurn] = useState(true);\n  const [test, setTest] = useState(false);\n  useEffect(() => {\n    generateComputerMap();\n    setFirstRender(true);\n  }, []);\n\n  useEffect(() => {\n    if (Object.values(player.shipsStatus).every((status) => status))\n      removeShadows();\n    if (\n      Object.values(player.shipsStatus).every((status) => status) &&\n      !firstTime\n    ) {\n      setIsBattle(true);\n      setLegendLineOne(strings.battle.placementCompleted);\n      setLegendLineTwo(\"\");\n    }\n\n    if (\n      Object.values(player.shipsStatus).every((status) => !status) &&\n      player.attempts &&\n      !firstTime\n    ) {\n      setLegendLineOne(strings.battle.lose);\n      setLegendLineTwo(\"\");\n      setPlayAgain(true);\n      setOpen(true);\n      setIsBattle(false);\n      setScore(\"computer\");\n    }\n    // removed player.damagedShip\n  }, [player.shipsStatus, firstTime]);\n\n  useEffect(() => {\n    if (\n      Object.values(computer.shipsStatus).every((status) => !status) &&\n      computer.attempts &&\n      !firstTime\n    ) {\n      setLegendLineOne(strings.battle.win);\n      setLegendLineTwo(\"\");\n      setPlayAgain(true);\n      setOpen(true);\n      setScore(\"player\");\n    }\n  }, [computer.shipsStatus, firstTime]);\n\n  console.log(playAgain, computer.shipsStatus, computer.attempts);\n\n  useEffect(() => {\n    if (player.ships.battleShip.length === 4) setFirstTime(false);\n  }, [player.ships.battleShip]);\n\n  const [playerAttempt, setPlayerAttempt] = useState(\"\");\n\n  // Why we need this??\n  useEffect(() => {\n    if (firstRender) {\n      setTimeout(() => checkComputerAttempt(), 2000);\n    }\n  }, [player.damagedShip.length]);\n\n  const oneMoreTimeGame = () => {\n    setPlayAgain(false);\n    clearEverything();\n    generateComputerMap();\n    setLegendLineOne(strings.battle.keepPlaying);\n    setLegendLineTwo(strings.battle.placeStartPoint);\n  };\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  // multifunctional methods necessary for player and computer as well\n\n  // method to generate random position on map\n  const randomPosition = () => {\n    const randomLetter = rows[Math.floor(Math.random() * rows.length)];\n    const randomNumber = columns[Math.floor(Math.random() * columns.length)];\n    return randomLetter + randomNumber;\n  };\n\n  // method to determine number part of cell consist of 1 or 2 digits (e.g d9 or d10)\n  const considerCellNumber = (cell: string) => {\n    return cell.length === 3 ? cell[1] + cell[2] : cell[1];\n  };\n\n  // method to calculate length of ship based on it's name\n  const calculateShipLength = (ship: string) => {\n    let shipLength = 1;\n    if (ship[0] === \"b\") shipLength = 4;\n    if (ship[0] === \"c\") shipLength = 3;\n    if (ship[0] === \"d\") shipLength = 2;\n    return shipLength;\n  };\n\n  // method to determine possible ship directions based on starting point and free cells around\n  const whereTurnShip = (\n    obj: any,\n    ship: string,\n    firstPoint: string,\n    shipDirections: string[]\n  ) => {\n    const shipLength = calculateShipLength(ship);\n    const number = considerCellNumber(firstPoint);\n    for (let i = 1; i < shipLength; i++) {\n      if (!obj[`${firstPoint[0]}${Number(number) - i}`])\n        shipDirections = shipDirections.filter((x) => x !== \"up\");\n      if (!obj[`${firstPoint[0]}${Number(number) + i}`])\n        shipDirections = shipDirections.filter((x) => x !== \"down\");\n      if (\n        !obj[`${String.fromCharCode(firstPoint[0].charCodeAt(0) - i)}${number}`]\n      )\n        shipDirections = shipDirections.filter((x) => x !== \"left\");\n      if (\n        !obj[`${String.fromCharCode(firstPoint[0].charCodeAt(0) + i)}${number}`]\n      )\n        shipDirections = shipDirections.filter((x) => x !== \"right\");\n    }\n    return shipDirections;\n  };\n\n  // method to create neighbour cells array considering non existing cells\n  const createNeighbourCellsArray = (cell: string, all = true) => {\n    const number = considerCellNumber(cell);\n    // create empty board to know which cells are exist\n    const board = generateFreeCells({});\n    // create array of all possble neigbour cells\n    let neighbourCells = [\n      upperNeighbour(cell),\n      downNeighbour(cell),\n      leftNeighbour(cell),\n      rightNeighbour(cell),\n    ];\n\n    if (all)\n      neighbourCells = [\n        ...neighbourCells,\n        `${String.fromCharCode(cell[0].charCodeAt(0) - 1)}${\n          Number(number) - 1\n        }`,\n        `${String.fromCharCode(cell[0].charCodeAt(0) - 1)}${\n          Number(number) + 1\n        }`,\n        `${String.fromCharCode(cell[0].charCodeAt(0) + 1)}${\n          Number(number) - 1\n        }`,\n        `${String.fromCharCode(cell[0].charCodeAt(0) + 1)}${\n          Number(number) + 1\n        }`,\n      ];\n    // return only filtered existing cells\n    return neighbourCells.filter((pos) => board[pos]);\n  };\n\n  // create array of ship cells together with shadows based on ship array\n  const fillShipArrayWithShadows = (shipPosition: string[]) => {\n    let shipPositionWithShadows: string[] = [];\n    shipPosition.forEach((pos: string) => {\n      const neighbourCells = createNeighbourCellsArray(pos);\n      shipPositionWithShadows = [\n        ...shipPositionWithShadows,\n        pos,\n        ...neighbourCells,\n      ];\n    });\n    // return only unique cells\n    return [...new Set(shipPositionWithShadows)];\n  };\n\n  // method to return corresponding object based on string\n  const whatTheSide = (side: string) => (side === \"player\" ? player : computer);\n\n  // methods to determine neighbour cells\n  const upperNeighbour = (cell: string) => {\n    const number = considerCellNumber(cell);\n    return `${cell[0]}${Number(number) + 1}`;\n  };\n  const downNeighbour = (cell: string) => {\n    const number = considerCellNumber(cell);\n    return `${cell[0]}${Number(number) - 1}`;\n  };\n  const leftNeighbour = (cell: string) => {\n    const number = considerCellNumber(cell);\n    return `${String.fromCharCode(cell[0].charCodeAt(0) - 1)}${number}`;\n  };\n  const rightNeighbour = (cell: string) => {\n    const number = considerCellNumber(cell);\n    return `${String.fromCharCode(cell[0].charCodeAt(0) + 1)}${number}`;\n  };\n\n  // method to determine what the ship based on catched cell, returns ship name\n  const whatTheShip = (side: string, value: string) => {\n    const sideObj = whatTheSide(side);\n    let currShip = \"\";\n    shipNames.forEach((ship) => {\n      if (sideObj.ships[ship].includes(value)) currShip = ship;\n    });\n    return currShip;\n  };\n\n  // method to determine what the ship index based on ship name\n  const whatTheShipIndex = (ship: string, shipNames: string[]) => {\n    return shipNames.findIndex((currShip) => currShip === ship);\n  };\n\n  // method to check was ship completely destroyed or not\n  const isShipDestroyed = (side: string, ship: string) => {\n    const sideObj = whatTheSide(side);\n    return sideObj.ships[ship].length === 1 ? true : false;\n  };\n\n  // method to remove cell from attempt from corresponding ship array\n  // and check was ship completely destroyed or not\n  const removeCellFromShip = (side: string, value: string) => {\n    const currentShip = whatTheShip(side, value);\n    const currentIndex: number = whatTheShipIndex(currentShip, shipNames);\n    removeShipCell(side, currentShip, value);\n    if (isShipDestroyed(side, currentShip)) {\n      if (side === \"player\") {\n        setLegendLineOne(\n          strings.battle.yourShipDestroyed.replace(\n            \"{}\",\n            shipNicknames[currentIndex]\n          )\n        );\n        setShipsStatus(\"player\", currentShip, false);\n      } else {\n        setLegendLineOne(\n          strings.battle.youDestroyedShip.replace(\n            \"{}\",\n            shipNicknames[currentIndex]\n          )\n        );\n        setShipsStatus(\"computer\", currentShip, false);\n      }\n    }\n  };\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  // generate computer ships and all related methods to computer methods\n\n  // method to generate starting point, only checks if point is not occupied\n  const generateStartingPoint = (obj: any) => {\n    // generate first attempt of ship starting point\n    let startingPoint = randomPosition();\n    // if starting point is occupied we need to generate another one\n    while (!obj[startingPoint]) {\n      startingPoint = randomPosition();\n    }\n    return startingPoint;\n  };\n\n  // method to fill ship array based on choosen direction\n  const fillShipArray = (ship: string, arr: string[], direction: string) => {\n    const number = considerCellNumber(arr[0]);\n    const shipLength = calculateShipLength(ship);\n    if (direction === \"up\") {\n      for (let i = 1; i < shipLength; i++) {\n        arr.push(`${arr[0][0]}${Number(number) - i}`);\n      }\n    }\n    if (direction === \"down\") {\n      for (let i = 1; i < shipLength; i++) {\n        arr.push(`${arr[0][0]}${Number(number) + i}`);\n      }\n    }\n    if (direction === \"left\") {\n      for (let i = 1; i < shipLength; i++) {\n        arr.push(\n          `${String.fromCharCode(arr[0][0].charCodeAt(0) - i)}${number}`\n        );\n      }\n    }\n    if (direction === \"right\") {\n      for (let i = 1; i < shipLength; i++) {\n        arr.push(\n          `${String.fromCharCode(arr[0][0].charCodeAt(0) + i)}${number}`\n        );\n      }\n    }\n    return arr;\n  };\n\n  // method to generate ship position based on current condition of map cells\n  const generateShip = (ship: string, obj: any) => {\n    // generate first cell of first ship\n    let firstCell = generateStartingPoint(obj);\n    let shipPosition = [];\n    shipPosition.push(firstCell);\n    // if it's not 1cell ship make sure that you can turn ship somewhere\n    if (ship[0] !== \"v\") {\n      let shipPossibleDirections = whereTurnShip(\n        obj,\n        ship,\n        firstCell,\n        direction\n      );\n      while (shipPossibleDirections.length === 0) {\n        firstCell = generateStartingPoint(obj);\n        shipPossibleDirections = whereTurnShip(obj, ship, firstCell, direction);\n      }\n      shipPosition[0] = firstCell;\n      // choose random direction of ship based on possible directions\n      const shipDirection =\n        shipPossibleDirections[\n          Math.floor(Math.random() * shipPossibleDirections.length)\n        ];\n      // add rest of ship coordinates to array to have full shape of ship\n      shipPosition = fillShipArray(ship, shipPosition, shipDirection);\n    }\n    return shipPosition;\n  };\n\n  // method to generate complete computer map of ships\n  const generateComputerMap = () => {\n    // object to storage ships positions\n    const ships = generateFreeCells({});\n    // object to storage ships positions with ships shadows\n    const shipsShadows = generateFreeCells({});\n    shipNames.forEach((ship) => {\n      const shipPosition = generateShip(ship, shipsShadows);\n      setShip(\"computer\", ship, shipPosition);\n      setShipsStatus(\"computer\", ship, true);\n      const shipPositionWithArrays = fillShipArrayWithShadows(shipPosition);\n      shipPosition.forEach((pos: string) => (ships[pos] = false));\n      shipPositionWithArrays.forEach(\n        (pos: string) => (shipsShadows[pos] = false)\n      );\n    });\n    // pass objects with information to corresponding reducers\n    setShipsCellsTotal(ships);\n    setShipsShadowsCellsTotal(\"computer\", shipsShadows);\n  };\n\n  // method to generate random computer attempt considering is this cell occupied with previous random or with shadow of guessed ship\n  const generateComputerAttempt = () => {\n    let currentAttempt = randomPosition();\n    while (\n      computer.wrongAttempts[currentAttempt] ||\n      !player.shipsShadowsCells[currentAttempt]\n    )\n      currentAttempt = randomPosition();\n    return currentAttempt;\n  };\n\n  // method how computer is going to guess next player ship cell based on\n  // quantity of already guessed cells\n  const guessNextPlayerShipCell = (ship: string[]) =>\n    ship.length === 1\n      ? guessBasedOnOneCell(ship[0])\n      : guessBasedOnTwoCells(ship);\n\n  // method to add cells to damaged ship\n  const addCellToDamagedShip = (cell: string) => {\n    const { damagedShip } = player;\n    if (damagedShip.length === 0) {\n      setDamagedShip([cell]);\n    } else {\n      const direction = determineShipDirection(damagedShip[0], cell);\n      const damagedShipCopy = damagedShip;\n      let necessaryIndex;\n      if (direction === strings.battle.vertical)\n        necessaryIndex = damagedShip.findIndex(\n          (currentCell: string) =>\n            Number(considerCellNumber(cell)) <\n            Number(considerCellNumber(currentCell))\n        );\n      if (direction === strings.battle.horizontal)\n        necessaryIndex = damagedShip.findIndex(\n          (currentCell: string) =>\n            cell.charCodeAt(0) < currentCell.charCodeAt(0)\n        );\n      if (necessaryIndex === -1) necessaryIndex = damagedShip.length;\n      damagedShipCopy.splice(necessaryIndex, 0, cell);\n      setDamagedShip(damagedShipCopy);\n    }\n  };\n\n  // method to determine ship direction based on ship coordinates\n  const determineShipDirection = (firstCell: string, lastCell: string) => {\n    return firstCell[0] === lastCell[0]\n      ? strings.battle.vertical\n      : strings.battle.horizontal;\n  };\n\n  // method for computer attempt after player attempt\n  const checkComputerAttempt = () => {\n    const { damagedShip } = player;\n    const currentAttempt =\n      damagedShip.length === 0\n        ? generateComputerAttempt()\n        : guessNextPlayerShipCell(damagedShip);\n    setWrongAttempts(\"computer\", currentAttempt);\n    setAttempts(\"computer\");\n    setLegendLineOne(strings.battle.computerTurn.replace(\"{}\", currentAttempt));\n    setLegendLineTwo(\"\");\n    // check if ship was damaged or not\n    if (!player.shipsCells[currentAttempt]) {\n      // if ship was damaged\n      setLegendLineTwo(strings.battle.computerCatched);\n      setKilledCells(\"player\", currentAttempt);\n      const damagedShipName: string = whatTheShip(\"player\", currentAttempt);\n      removeCellFromShip(\"player\", currentAttempt);\n      // check if ship was completely destroyed or not\n      if (isShipDestroyed(\"player\", damagedShipName)) {\n        // if completely destroyed we just looking for new random cell\n        const destroyedShipShadows = fillShipArrayWithShadows([\n          ...damagedShip,\n          currentAttempt,\n        ]);\n        const playerShipsShadowsCellsCopy = player.shipsShadowsCells;\n        destroyedShipShadows.forEach(\n          (cell: string) => (playerShipsShadowsCellsCopy[cell] = false)\n        );\n        setShipsShadowsCellsTotal(\"player\", playerShipsShadowsCellsCopy);\n        setDamagedShip([]);\n        if (damagedShipName[0] === \"v\")\n          setTimeout(() => checkComputerAttempt(), 2000);\n      } else {\n        addCellToDamagedShip(currentAttempt);\n      }\n    } else {\n      setTimeout(() => {\n        setLegendLineOne(strings.battle.computerMissed);\n        setLegendLineTwo(strings.battle.yourTurn);\n        setPlayerTurn(true);\n      }, 2000);\n    }\n  };\n\n  // method to provide random neighbour cell based on one cell\n  const guessBasedOnOneCell = (cell: string) => {\n    // we need to filter array of cells to make sure that we not tried this cell before and it's not lying on other ship shadow\n    const neighbourCells = createNeighbourCellsArray(cell, false);\n    const filteredneighbourCells = neighbourCells.filter(\n      (cell) => !computer.wrongAttempts[cell] && player.shipsShadowsCells[cell]\n    );\n    // take random cell from filtered array\n    let randomNeigbourCell =\n      filteredneighbourCells[\n        Math.floor(Math.random() * filteredneighbourCells.length)\n      ];\n    return randomNeigbourCell;\n  };\n\n  // guessing next player cell if we have 2 cells of damaged ship\n  const guessBasedOnTwoCells = (ship: string[]) => {\n    const direction = determineShipDirection(ship[0], ship[ship.length - 1]);\n    const neighbourCells = [];\n    if (direction === strings.battle.vertical) {\n      neighbourCells.push(\n        `${ship[0][0]}${Number(considerCellNumber(ship[0])) - 1}`\n      );\n      neighbourCells.push(\n        `${ship[0][0]}${Number(considerCellNumber(ship[ship.length - 1])) + 1}`\n      );\n    }\n    if (direction === strings.battle.horizontal) {\n      const thisCellNumber = considerCellNumber(ship[0]);\n      neighbourCells.push(\n        `${String.fromCharCode(ship[0].charCodeAt(0) - 1)}${thisCellNumber}`\n      );\n      neighbourCells.push(\n        `${String.fromCharCode(\n          ship[ship.length - 1].charCodeAt(0) + 1\n        )}${thisCellNumber}`\n      );\n    }\n    const filteredneighbourCells = neighbourCells.filter(\n      (cell) => !computer.wrongAttempts[cell] && player.shipsShadowsCells[cell]\n    );\n    return filteredneighbourCells.length === 1\n      ? filteredneighbourCells[0]\n      : filteredneighbourCells[\n          Math.floor(Math.random() * filteredneighbourCells.length)\n        ];\n  };\n\n  const determineCurrentShip = () => {\n    const { ships } = player;\n    let currentShip = \"\";\n    let index = 0;\n    if (!ships.battleShip.length || ships.battleShip.length < 4)\n      currentShip = shipNames[0];\n    else if (!ships.cruiserFirst.length || ships.cruiserFirst.length < 3) {\n      currentShip = shipNames[1];\n      index = 1;\n    } else if (!ships.cruiserSecond.length || ships.cruiserSecond.length < 3) {\n      currentShip = shipNames[2];\n      index = 2;\n    } else if (\n      !ships.destroyerFirst.length ||\n      ships.destroyerFirst.length < 2\n    ) {\n      currentShip = shipNames[3];\n      index = 3;\n    } else if (\n      !ships.destroyerSecond.length ||\n      ships.destroyerSecond.length < 2\n    ) {\n      currentShip = shipNames[4];\n      index = 4;\n    } else if (\n      !ships.destroyerThird.length ||\n      ships.destroyerThird.length < 2\n    ) {\n      currentShip = shipNames[5];\n      index = 5;\n    } else if (!ships.vedetteFirst.length || ships.vedetteFirst.length < 1) {\n      currentShip = shipNames[6];\n      index = 6;\n    } else if (!ships.vedetteSecond.length || ships.vedetteSecond.length < 1) {\n      currentShip = shipNames[7];\n      index = 7;\n    } else if (!ships.vedetteThird.length || ships.vedetteThird.length < 1) {\n      currentShip = shipNames[8];\n      index = 8;\n    } else if (!ships.vedetteForth.length || ships.vedetteForth.length < 1) {\n      currentShip = shipNames[9];\n      index = 9;\n    }\n    return {\n      currentShip,\n      index,\n    };\n  };\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  // methods for player playing\n\n  // method to place player's ship on map\n  const placePlayerShipOnMap = (cellNumber: string) => {\n    const { ships } = player;\n    const shipObj = determineCurrentShip();\n    const currentShip = shipObj.currentShip;\n    const index = shipObj.index;\n\n    if (\n      (player.shipsCells[cellNumber] &&\n        !ships[currentShip]?.length &&\n        player.shipsShadowsCells[cellNumber]) ||\n      (player.shipsCells[cellNumber] && player.possibleDirections[cellNumber])\n    ) {\n      if (player.ships[currentShip].length === shipLengths[index] - 1) {\n        setShipsStatus(\"player\", currentShip, true);\n        setLegendLineOne(\n          strings.battle.completed.replace(\"{}\", shipNicknames[index])\n        );\n        setLegendLineTwo(\n          strings.battle.proposition.replace(\"{}\", shipNicknames[index + 1])\n        );\n      }\n      if (\n        (index === 0 && ships[currentShip]?.length < shipLengths[index]) ||\n        (index > 0 &&\n          ships[shipNames[index - 1]]?.length === shipLengths[index - 1] &&\n          ships[currentShip]?.length < shipLengths[index])\n      ) {\n        setShip(\"player\", shipNames[index], [cellNumber]);\n        setShipsCells(\"player\", cellNumber);\n\n        if (ships[currentShip]?.length === shipLengths[index] - 1) {\n          const currentShipShadow = fillShipArrayWithShadows([\n            ...ships[currentShip],\n            cellNumber,\n          ]);\n          currentShipShadow.forEach((cell) =>\n            setShipsShadowsCells(\"player\", cell)\n          );\n        }\n        if (ships[currentShip]?.length === 0 && index < 6) {\n          const directions = whereTurnShip(\n            player.shipsShadowsCells,\n            currentShip,\n            cellNumber,\n            direction\n          );\n          directions.forEach((dir) =>\n            fillPossibleDirection(currentShip, [cellNumber], dir)\n          );\n        }\n        if (ships[currentShip]?.length < shipLengths[index] - 1 && index < 6) {\n          setLegendLineOne(\"Good job!\");\n          setLegendLineTwo(\n            `Keep working on placing the ${shipNicknames[index]} on the map`\n          );\n        }\n        if (ships[currentShip]?.length === 1 && index < 6) {\n          removePossibleDirections();\n          const dir = determineDirection(ships[currentShip][0], cellNumber);\n          fillPossibleDirection(currentShip, [ships[currentShip][0]], dir);\n        }\n      }\n    } else if (\n      player.shipsCells[cellNumber] &&\n      ships[currentShip].length &&\n      !player.possibleDirections[cellNumber]\n    ) {\n      setLegendLineOne(\"Please, choose cell from ship shadow\");\n      setLegendLineTwo(\"\");\n    } else if (\n      player.shipsCells[cellNumber] &&\n      !ships[currentShip].length &&\n      !player.shipsShadowsCells[cellNumber]\n    ) {\n      setLegendLineOne(\n        \"Make sure that you don't place ship close to another one\"\n      );\n      setLegendLineTwo(\"\");\n    }\n  };\n\n  const clickOnComputerField = () => {\n    if (!isBattle) {\n      setLegendLineOne(\n        \"Make sure that you are not trying to place your ship on computer field\"\n      );\n      setLegendLineTwo(\"\");\n    }\n  };\n\n  // method to check was attempt wrong or not\n  const checkPlayerAttempt = (value: string) => {\n    const correctedValue = value.toLowerCase();\n    if (!playerTurn) {\n      setLegendLineOne(strings.battle.notYourTurn);\n      setLegendLineTwo(strings.battle.wait);\n    } else {\n      setLegendLineOne(\n        strings.battle.yourAttempt.replace(\"{}\", correctedValue)\n      );\n      setLegendLineTwo(\"\");\n      if (player.wrongAttempts[value]) {\n        setLegendLineTwo(strings.battle.alreadyTried);\n      } else if (computer.shipsCells[correctedValue] === undefined) {\n        setLegendLineTwo(strings.battle.cellNotExist);\n      } else {\n        setWrongAttempts(\"player\", correctedValue);\n        setAttempts(\"player\");\n        if (!computer.shipsCells[correctedValue]) {\n          const currentShip = whatTheShip(\"computer\", value);\n          if (isShipDestroyed(\"computer\", currentShip)) {\n            setLegendLineTwo(strings.battle.oneMoreTry);\n          } else {\n            setLegendLineTwo(strings.battle.youCatched);\n          }\n          setKilledCells(\"computer\", correctedValue);\n          removeCellFromShip(\"computer\", correctedValue);\n        } else {\n          setLegendLineTwo(strings.battle.youMissed);\n          setPlayerTurn(false);\n          setTimeout(() => {\n            checkComputerAttempt();\n          }, 2000);\n        }\n      }\n    }\n  };\n\n  // method to fill possible directions\n  const fillPossibleDirection = (\n    ship: string,\n    cell: string[],\n    direction: string\n  ) => {\n    const shipPosition = fillShipArray(ship, cell, direction);\n    shipPosition.forEach((shipCell: string, cellIndex: number) => {\n      if (cellIndex > 0) setPossibleDirections(shipCell);\n    });\n  };\n\n  // method to determine ship direction based on started and second points\n  const determineDirection = (cellFirst: string, cellSecond: string) => {\n    const cellFirstNumber = considerCellNumber(cellFirst);\n    const cellSecondNumber = considerCellNumber(cellSecond);\n    return cellFirst[0] === cellSecond[0]\n      ? Number(cellFirstNumber) > Number(cellSecondNumber)\n        ? \"up\"\n        : \"down\"\n      : String.fromCharCode(cellFirst[0].charCodeAt(0) - 1) === cellSecond[0]\n      ? \"left\"\n      : \"right\";\n  };\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  // front-end methods\n\n  const killPlayer = () => {\n    shipNames.forEach((ship) => setShipsStatus(\"player\", ship, false));\n    setFirstTime(false);\n    setAttempts(\"player\");\n    setOpen(true);\n  };\n\n  const killComputer = () => {\n    shipNames.forEach((ship) => setShipsStatus(\"computer\", ship, false));\n    setFirstTime(false);\n    setAttempts(\"computer\");\n    setOpen(true);\n  };\n\n  return (\n    <Fragment>\n      <Grid\n        container\n        style={{ marginBottom: 20 }}\n        direction=\"column\"\n        alignItems=\"center\"\n      >\n        <Typography style={{ color: \"white\" }} variant=\"h5\">\n          Score:\n        </Typography>\n        <Typography style={{ color: \"white\" }} variant=\"h5\">\n          {score[0]}:{score[1]}\n        </Typography>\n        <Modal\n          open={open}\n          aria-labelledby=\"simple-modal-title\"\n          aria-describedby=\"simple-modal-description\"\n          style={{\n            display: \"flex\",\n            alignItems: \"center\",\n            justifyContent: \"center\",\n          }}\n        >\n          <PlayAgain oneMoreGame={oneMoreTimeGame} handleOpen={setOpen} />\n        </Modal>\n      </Grid>\n      <Grid\n        container\n        direction=\"row\"\n        spacing={5}\n        justify=\"center\"\n        style={{ backgroundColor: \"white\" }}\n      >\n        <Grid item>\n          <Grid container direction=\"column\" alignItems=\"center\">\n            <Typography variant=\"h4\">{playerName}</Typography>\n            <Typography\n              style={{ marginTop: 20 }}\n              variant=\"h6\"\n            >{`Attempts: ${player.attempts}`}</Typography>\n            <Field side={\"player\"} placeShipOnMap={placePlayerShipOnMap} />\n            {isBattle ? (\n              <React.Fragment>\n                <Grid item style={{ marginTop: 40 }}>\n                  <Grid container direction=\"row\" spacing={2} justify=\"center\">\n                    <Grid item>\n                      <TextField\n                        variant=\"outlined\"\n                        style={{ width: 70, height: 10 }}\n                        onChange={(event) =>\n                          setPlayerAttempt(event.target.value)\n                        }\n                        onKeyDown={(e) => {\n                          if (e.keyCode === 13)\n                            checkPlayerAttempt(playerAttempt);\n                        }}\n                      />\n                    </Grid>\n                    <Grid item style={{ marginTop: 10 }}>\n                      <Button\n                        variant=\"contained\"\n                        color=\"primary\"\n                        onClick={() => checkPlayerAttempt(playerAttempt)}\n                      >\n                        Enter cell\n                      </Button>\n                    </Grid>\n                  </Grid>\n                </Grid>\n                <Grid item style={{ marginTop: 10 }}>\n                  <Legend side={player} player=\"player\" />\n                </Grid>\n              </React.Fragment>\n            ) : null}\n          </Grid>\n        </Grid>\n        <Grid item>\n          <Grid container direction=\"column\" alignItems=\"center\">\n            <Typography variant=\"h4\">Computer</Typography>\n            <Typography\n              style={{ marginTop: 20 }}\n              variant=\"h6\"\n            >{`Attempts: ${computer.attempts}`}</Typography>\n            <Field side={\"computer\"} placeShipOnMap={clickOnComputerField} />\n            <Grid item style={{ marginTop: 97 }}>\n              {isBattle ? <Legend side={computer} /> : null}\n            </Grid>\n          </Grid>\n        </Grid>\n      </Grid>\n      <Grid container direction=\"row\" spacing={2}>\n        <Grid item>\n          <CustomButton onClick={() => setTest(!test)}>\n            Testing Buttons\n          </CustomButton>\n        </Grid>\n        {test ? (\n          <Fragment>\n            <Grid item>\n              <Button variant=\"contained\" color=\"primary\" onClick={killPlayer}>\n                Kill player\n              </Button>\n            </Grid>\n            <Grid item>\n              <Button\n                variant=\"contained\"\n                color=\"primary\"\n                onClick={killComputer}\n              >\n                Kill computer\n              </Button>\n            </Grid>\n            <Grid item>\n              <Button\n                variant=\"contained\"\n                color=\"primary\"\n                onClick={setShowComputer}\n              >\n                {showComputer ? \"Hide Ships\" : \"Show Ships\"}\n              </Button>\n            </Grid>\n          </Fragment>\n        ) : null}\n      </Grid>\n    </Fragment>\n  );\n};\n\nconst mapStateToProps = (state: any) => {\n  const {\n    player,\n    computer,\n    showComputer,\n    playAgain,\n    firstTime,\n    isBattle,\n    score,\n    playerName,\n    playerTurn,\n  } = state;\n  return {\n    player,\n    computer,\n    showComputer,\n    playAgain,\n    firstTime,\n    isBattle,\n    score,\n    playerName,\n    playerTurn,\n  };\n};\n\nconst mapDispatchToProps = (dispatch: any) => ({\n  setShip: (player: string, ship: string, position: string[]) =>\n    dispatch(setShip(player, ship, position)),\n  setShipsCells: (player: string, cell: string) =>\n    dispatch(setShipsCells(player, cell)),\n  setShipsShadowsCells: (player: string, cell: string) =>\n    dispatch(setShipsShadowsCells(player, cell)),\n  setLegendLineTwo: (legend: string) => dispatch(setLegendLineTwo(legend)),\n  setLegendLineOne: (legend: string) => dispatch(setLegendLineOne(legend)),\n  setShowComputer: () => dispatch(setShowComputer()),\n  setShipsStatus: (player: string, ship: string, status: boolean) =>\n    dispatch(setShipsStatus(player, ship, status)),\n  setKilledCells: (player: string, cell: string) =>\n    dispatch(setKilledCells(player, cell)),\n  removeShipCell: (player: string, ship: string, cell: string) =>\n    dispatch(removeShipCell(player, ship, cell)),\n  setWrongAttempts: (player: string, attempt: string) =>\n    dispatch(setWrongAttempts(player, attempt)),\n  setPossibleDirections: (cell: string) =>\n    dispatch(setPossibleDirections(cell)),\n  removePossibleDirections: () => dispatch(removePossibleDirections()),\n  setAttempts: (player: string) => dispatch(setAttempts(player)),\n  setShipsCellsTotal: (obj: any) => dispatch(setShipsCellsTotal(obj)),\n  setShipsShadowsCellsTotal: (player: string, obj: any) =>\n    dispatch(setShipsShadowsCellsTotal(player, obj)),\n  removeShadows: () => dispatch(removeShadows()),\n  setPlayAgain: (status: boolean) => dispatch(setPlayAgain(status)),\n  setFirstTime: (status: boolean) => dispatch(setFirstTime(status)),\n  clearEverything: () => dispatch(clearEverything()),\n  setDamagedShip: (ship: string[]) => dispatch(setDamagedShip(ship)),\n  setIsBattle: (status: boolean) => dispatch(setIsBattle(status)),\n  setScore: (side: string) => dispatch(setScore(side)),\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Battle);\n","/home/averemyeyev/andriy/projects/battleship/src/strings.ts",[],"/home/averemyeyev/andriy/projects/battleship/src/actions/index.ts",[],"/home/averemyeyev/andriy/projects/battleship/src/PlayAgain.tsx",[],"/home/averemyeyev/andriy/projects/battleship/src/Legend.tsx",[],"/home/averemyeyev/andriy/projects/battleship/src/Field.tsx",[],"/home/averemyeyev/andriy/projects/battleship/src/components/CustomButton.tsx",[],{"ruleId":"79","replacedBy":"80"},{"ruleId":"81","replacedBy":"82"},{"ruleId":"83","severity":1,"message":"84","line":143,"column":6,"nodeType":"85","endLine":143,"endColumn":8,"suggestions":"86"},{"ruleId":"83","severity":1,"message":"87","line":170,"column":6,"nodeType":"85","endLine":170,"endColumn":37,"suggestions":"88"},{"ruleId":"83","severity":1,"message":"89","line":184,"column":6,"nodeType":"85","endLine":184,"endColumn":39,"suggestions":"90"},{"ruleId":"83","severity":1,"message":"91","line":190,"column":6,"nodeType":"85","endLine":190,"endColumn":31,"suggestions":"92"},{"ruleId":"83","severity":1,"message":"93","line":199,"column":6,"nodeType":"85","endLine":199,"endColumn":33,"suggestions":"94"},"no-native-reassign",["95"],"no-negated-in-lhs",["96"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'generateComputerMap'. Either include it or remove the dependency array.","ArrayExpression",["97"],"React Hook useEffect has missing dependencies: 'player.attempts', 'removeShadows', 'setIsBattle', 'setLegendLineOne', 'setLegendLineTwo', 'setPlayAgain', and 'setScore'. Either include them or remove the dependency array.",["98"],"React Hook useEffect has missing dependencies: 'computer.attempts', 'setLegendLineOne', 'setLegendLineTwo', 'setPlayAgain', and 'setScore'. Either include them or remove the dependency array.",["99"],"React Hook useEffect has a missing dependency: 'setFirstTime'. Either include it or remove the dependency array.",["100"],"React Hook useEffect has missing dependencies: 'checkComputerAttempt' and 'firstRender'. Either include them or remove the dependency array.",["101"],"no-global-assign","no-unsafe-negation",{"desc":"102","fix":"103"},{"desc":"104","fix":"105"},{"desc":"106","fix":"107"},{"desc":"108","fix":"109"},{"desc":"110","fix":"111"},"Update the dependencies array to be: [generateComputerMap]",{"range":"112","text":"113"},"Update the dependencies array to be: [player.shipsStatus, firstTime, player.attempts, removeShadows, setIsBattle, setLegendLineOne, setLegendLineTwo, setPlayAgain, setScore]",{"range":"114","text":"115"},"Update the dependencies array to be: [computer.attempts, computer.shipsStatus, firstTime, setLegendLineOne, setLegendLineTwo, setPlayAgain, setScore]",{"range":"116","text":"117"},"Update the dependencies array to be: [player.ships.battleShip, setFirstTime]",{"range":"118","text":"119"},"Update the dependencies array to be: [checkComputerAttempt, firstRender, player.damagedShip.length]",{"range":"120","text":"121"},[3730,3732],"[generateComputerMap]",[4418,4449],"[player.shipsStatus, firstTime, player.attempts, removeShadows, setIsBattle, setLegendLineOne, setLegendLineTwo, setPlayAgain, setScore]",[4762,4795],"[computer.attempts, computer.shipsStatus, firstTime, setLegendLineOne, setLegendLineTwo, setPlayAgain, setScore]",[4959,4984],"[player.ships.battleShip, setFirstTime]",[5179,5206],"[checkComputerAttempt, firstRender, player.damagedShip.length]"]