[{"/home/averemyeyev/andriy/projects/battleship/src/index.tsx":"1","/home/averemyeyev/andriy/projects/battleship/src/store.ts":"2","/home/averemyeyev/andriy/projects/battleship/src/App.tsx":"3","/home/averemyeyev/andriy/projects/battleship/src/reducers/index.ts":"4","/home/averemyeyev/andriy/projects/battleship/src/GameController.tsx":"5","/home/averemyeyev/andriy/projects/battleship/src/database.ts":"6","/home/averemyeyev/andriy/projects/battleship/src/Header.tsx":"7","/home/averemyeyev/andriy/projects/battleship/src/Battle.tsx":"8","/home/averemyeyev/andriy/projects/battleship/src/StartGame.tsx":"9","/home/averemyeyev/andriy/projects/battleship/src/strings.ts":"10","/home/averemyeyev/andriy/projects/battleship/src/actions/index.ts":"11","/home/averemyeyev/andriy/projects/battleship/src/EnterName.tsx":"12","/home/averemyeyev/andriy/projects/battleship/src/Field.tsx":"13","/home/averemyeyev/andriy/projects/battleship/src/PlayAgain.tsx":"14"},{"size":506,"mtime":1620950325338,"results":"15","hashOfConfig":"16"},{"size":137,"mtime":1620679181954,"results":"17","hashOfConfig":"16"},{"size":215,"mtime":1620951140062,"results":"18","hashOfConfig":"16"},{"size":6369,"mtime":1620784704638,"results":"19","hashOfConfig":"16"},{"size":828,"mtime":1620754395404,"results":"20","hashOfConfig":"16"},{"size":1156,"mtime":1620679181954,"results":"21","hashOfConfig":"16"},{"size":1343,"mtime":1620954027686,"results":"22","hashOfConfig":"16"},{"size":30948,"mtime":1620955050181,"results":"23","hashOfConfig":"16"},{"size":1537,"mtime":1620953774229,"results":"24","hashOfConfig":"16"},{"size":716,"mtime":1620922983327,"results":"25","hashOfConfig":"16"},{"size":3014,"mtime":1620766650033,"results":"26","hashOfConfig":"16"},{"size":2102,"mtime":1620952737346,"results":"27","hashOfConfig":"16"},{"size":3534,"mtime":1620921890649,"results":"28","hashOfConfig":"16"},{"size":1265,"mtime":1620955247976,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"uu5yiq",{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"32"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"58"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"/home/averemyeyev/andriy/projects/battleship/src/index.tsx",[],["61","62"],"/home/averemyeyev/andriy/projects/battleship/src/store.ts",[],"/home/averemyeyev/andriy/projects/battleship/src/App.tsx",[],"/home/averemyeyev/andriy/projects/battleship/src/reducers/index.ts",[],"/home/averemyeyev/andriy/projects/battleship/src/GameController.tsx",[],"/home/averemyeyev/andriy/projects/battleship/src/database.ts",[],"/home/averemyeyev/andriy/projects/battleship/src/Header.tsx",[],"/home/averemyeyev/andriy/projects/battleship/src/Battle.tsx",["63","64","65","66","67","68"],"import React, { useState, useEffect, Fragment } from \"react\";\nimport { connect } from \"react-redux\";\nimport { Grid, Typography, Button, TextField, Modal } from \"@material-ui/core\";\n// import { makeStyles } from \"@material-ui/styles\";\nimport Field from \"./Field\";\nimport PlayAgain from \"./PlayAgain\";\n\nimport {\n  setShip,\n  setShipsCells,\n  setShipsShadowsCells,\n  setLegendLineOne,\n  setLegendLineTwo,\n  setShipsStatus,\n  setWrongAttempts,\n  setAttempts,\n  setShowComputer,\n  setKilledCells,\n  removeShipCell,\n  setPossibleDirections,\n  removePossibleDirections,\n  setShipsCellsTotal,\n  setShipsShadowsCellsTotal,\n  removeShadows,\n  setPlayAgain,\n  setFirstTime,\n  clearEverything,\n  setDamagedShip,\n  setIsBattle,\n  setScore,\n} from \"./actions/index\";\n\nimport {\n  rows,\n  columns,\n  shipNames,\n  direction,\n  shipLengths,\n  shipNicknames,\n  generateFreeCells,\n} from \"./database\";\nimport strings from \"./strings\";\n\ntype BattleProps = {\n  setShip: any;\n  setShipsCells: any;\n  setShipsShadowsCells: any;\n  computer: any;\n  setLegendLineOne: any;\n  setLegendLineTwo: any;\n  player: any;\n  setShipsStatus: any;\n  setShowComputer: any;\n  showComputer: any;\n  setKilledCells: any;\n  removeShipCell: any;\n  setWrongAttempts: any;\n  setPossibleDirections: any;\n  removePossibleDirections: any;\n  setAttempts: any;\n  setShipsCellsTotal: any;\n  setShipsShadowsCellsTotal: any;\n  removeShadows: any;\n  setPlayAgain: any;\n  playAgain: boolean;\n  setFirstTime: any;\n  firstTime: boolean;\n  clearEverything: any;\n  setDamagedShip: any;\n  setIsBattle: any;\n  isBattle: boolean;\n  setScore: any;\n  score: number[];\n  playerName: string;\n};\n\n// const useStyles = makeStyles({\n// });\n\nconst Battle: React.FC<BattleProps> = (props) => {\n  // to generate computer map once battle is mounted\n\n  // const classes = useStyles();\n\n  const {\n    setShip,\n    setShipsCells,\n    setShipsShadowsCells,\n    computer,\n    setLegendLineOne,\n    setLegendLineTwo,\n    player,\n    setShipsStatus,\n    setShowComputer,\n    showComputer,\n    setKilledCells,\n    removeShipCell,\n    setWrongAttempts,\n    setPossibleDirections,\n    removePossibleDirections,\n    setAttempts,\n    setShipsCellsTotal,\n    setShipsShadowsCellsTotal,\n    removeShadows,\n    setPlayAgain,\n    playAgain,\n    setFirstTime,\n    firstTime,\n    clearEverything,\n    setDamagedShip,\n    setIsBattle,\n    isBattle,\n    setScore,\n    score,\n    playerName,\n  } = props;\n  const [firstRender, setFirstRender] = useState(false);\n  const [open, setOpen] = useState(false);\n\n  useEffect(() => {\n    generateComputerMap();\n    setFirstRender(true);\n  }, []);\n\n  // to monitor changes in\n  useEffect(() => {\n    drawPossibleDirections();\n  }, [player.shipsCells]);\n\n  useEffect(() => {\n    if (Object.values(player.shipsStatus).every((status) => status))\n      removeShadows();\n    if (\n      Object.values(player.shipsStatus).every((status) => status) &&\n      !firstTime\n    )\n      setIsBattle(true);\n    if (\n      Object.values(player.shipsStatus).every((status) => !status) &&\n      !firstTime\n    ) {\n      setLegendLineOne(\"Unfortunately you lost the game\");\n      setLegendLineTwo(\"\");\n      setPlayAgain(true);\n      setIsBattle(false);\n      setScore(\"player\");\n    }\n  }, [player.shipsStatus, firstTime, player.damagedShip]);\n\n  useEffect(() => {\n    if (\n      Object.values(computer.shipsStatus).every((status) => !status) &&\n      !firstTime\n    ) {\n      setLegendLineOne(\"Congratulations! You won the game\");\n      setLegendLineTwo(\"\");\n      setPlayAgain(true);\n      setScore(\"computer\");\n    }\n  }, [computer.shipsStatus, firstTime]);\n\n  useEffect(() => {\n    if (player.battleShip.length === 4) setFirstTime(false);\n  }, [player.battleShip]);\n\n  const [playerAttempt, setPlayerAttempt] = useState(\"\");\n\n  useEffect(() => {\n    if (firstRender) {\n      setTimeout(() => checkComputerAttempt(), 2000);\n    }\n  }, [player.damagedShip.length]);\n\n  const oneMoreTimeGame = () => {\n    clearEverything();\n    generateComputerMap();\n    setPlayAgain(false);\n    setLegendLineOne(\"Glad that you decided to keep playing in the game\");\n    setLegendLineTwo(\n      \"Choose cell on player map to place start point of Battleship\"\n    );\n  };\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  // multifunctional methods necessary for player and computer as well\n\n  // method to generate random position on map\n  const randomPosition = () => {\n    const randomLetter = rows[Math.floor(Math.random() * rows.length)];\n    const randomNumber = columns[Math.floor(Math.random() * columns.length)];\n    return randomLetter + randomNumber;\n  };\n\n  // method to determine number part of cell consist of 1 or 2 digits (e.g d9 or d10)\n  const considerCellNumber = (cell: string) => {\n    return cell.length === 3 ? cell[1] + cell[2] : cell[1];\n  };\n\n  // method to calculate length of ship based on it's name\n  const calculateShipLength = (ship: string) => {\n    let shipLength = 1;\n    if (ship[0] === \"b\") shipLength = 4;\n    if (ship[0] === \"c\") shipLength = 3;\n    if (ship[0] === \"d\") shipLength = 2;\n    return shipLength;\n  };\n\n  // method to determine possible ship directions based on starting point and free cells around\n  const whereTurnShip = (\n    obj: any,\n    ship: string,\n    firstPoint: string,\n    shipDirections: string[]\n  ) => {\n    const shipLength = calculateShipLength(ship);\n    const number = considerCellNumber(firstPoint);\n    for (let i = 1; i < shipLength; i++) {\n      if (!obj[`${firstPoint[0]}${Number(number) - i}`])\n        shipDirections = shipDirections.filter((x) => x !== \"up\");\n      if (!obj[`${firstPoint[0]}${Number(number) + i}`])\n        shipDirections = shipDirections.filter((x) => x !== \"down\");\n      if (\n        !obj[`${String.fromCharCode(firstPoint[0].charCodeAt(0) - i)}${number}`]\n      )\n        shipDirections = shipDirections.filter((x) => x !== \"left\");\n      if (\n        !obj[`${String.fromCharCode(firstPoint[0].charCodeAt(0) + i)}${number}`]\n      )\n        shipDirections = shipDirections.filter((x) => x !== \"right\");\n    }\n    return shipDirections;\n  };\n\n  // method to create neighbour cells array considering non existing cells\n  const createNeighbourCellsArray = (cell: string, all = true) => {\n    const number = considerCellNumber(cell);\n    // create empty board to know which cells are exist\n    const board = generateFreeCells({});\n    // create array of all possble neigbour cells\n    let neighbourCells = [\n      upperNeighbour(cell),\n      downNeighbour(cell),\n      leftNeighbour(cell),\n      rightNeighbour(cell),\n    ];\n\n    if (all)\n      neighbourCells = [\n        ...neighbourCells,\n        `${String.fromCharCode(cell[0].charCodeAt(0) - 1)}${\n          Number(number) - 1\n        }`,\n        `${String.fromCharCode(cell[0].charCodeAt(0) - 1)}${\n          Number(number) + 1\n        }`,\n        `${String.fromCharCode(cell[0].charCodeAt(0) + 1)}${\n          Number(number) - 1\n        }`,\n        `${String.fromCharCode(cell[0].charCodeAt(0) + 1)}${\n          Number(number) + 1\n        }`,\n      ];\n    // return only filtered existing cells\n    return neighbourCells.filter((pos) => board[pos]);\n  };\n\n  // create array of ship cells together with shadows based on ship array\n  const fillShipArrayWithShadows = (shipPosition: any) => {\n    let shipPositionWithShadows: any = [];\n    shipPosition.forEach((pos: any) => {\n      const neighbourCells = createNeighbourCellsArray(pos);\n      shipPositionWithShadows = [\n        ...shipPositionWithShadows,\n        pos,\n        ...neighbourCells,\n      ];\n    });\n    // return only unique cells\n    return [...new Set(shipPositionWithShadows)];\n  };\n\n  // method to return corresponding object based on string\n  const whatTheSide = (side: string) => (side === \"player\" ? player : computer);\n\n  // methods to determine neighbour cells\n  const upperNeighbour = (cell: any) => {\n    const number = considerCellNumber(cell);\n    return `${cell[0]}${Number(number) + 1}`;\n  };\n  const downNeighbour = (cell: any) => {\n    const number = considerCellNumber(cell);\n    return `${cell[0]}${Number(number) - 1}`;\n  };\n  const leftNeighbour = (cell: any) => {\n    const number = considerCellNumber(cell);\n    return `${String.fromCharCode(cell[0].charCodeAt(0) - 1)}${number}`;\n  };\n  const rightNeighbour = (cell: any) => {\n    const number = considerCellNumber(cell);\n    return `${String.fromCharCode(cell[0].charCodeAt(0) + 1)}${number}`;\n  };\n\n  // method to determine what the ship based on catched cell, returns ship name\n  const whatTheShip = (side: any, value: any) => {\n    const sideObj = whatTheSide(side);\n    let currShip = null;\n    shipNames.forEach((ship) => {\n      if (sideObj[ship].includes(value)) currShip = ship;\n    });\n    return currShip;\n  };\n\n  // method to determine what the ship index based on ship name\n  const whatTheShipIndex = (ship: any) => {\n    let index;\n    shipNames.forEach((currShip, currIndex) => {\n      if (currShip === ship) index = currIndex;\n    });\n    return index;\n  };\n\n  // method to check was ship completely destroyed or not\n  const isShipDestroyed = (side: any, ship: any) => {\n    const sideObj = whatTheSide(side);\n    return sideObj[ship].length === 1 ? true : false;\n  };\n\n  // method to remove cell from attempt from corresponding ship array\n  // and check was ship completely destroyed or not\n  const removeCellFromShip = (side: any, value: any) => {\n    const currentShip = whatTheShip(side, value);\n    const currentIndex: any = whatTheShipIndex(currentShip);\n    console.log(\"remove ship cell\", side, currentShip, value);\n    removeShipCell(side, currentShip, value);\n    if (isShipDestroyed(side, currentShip)) {\n      if (side === \"player\") {\n        setLegendLineOne(\n          `Oops. Your ${shipNicknames[currentIndex]} was completely destroyed`\n        );\n        setShipsStatus(\"player\", currentShip, false);\n      } else {\n        setLegendLineOne(\n          `Congratulations! You completely destroyed ${shipNicknames[currentIndex]}`\n        );\n        setShipsStatus(\"computer\", currentShip, false);\n      }\n    }\n  };\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  // generate computer ships and all related methods to computer methods\n\n  // method to generate starting point, only checks if point is not occupied\n  const generateStartingPoint = (obj: any) => {\n    // generate first attempt of ship starting point\n    let startingPoint = randomPosition();\n    // if starting point is occupied we need to generate another one\n    while (!obj[startingPoint]) {\n      startingPoint = randomPosition();\n    }\n    return startingPoint;\n  };\n\n  // method to fill ship array based on choosen direction\n  const fillShipArray = (ship: any, arr: any, direction: any) => {\n    const number = considerCellNumber(arr[0]);\n    const shipLength = calculateShipLength(ship);\n    if (direction === \"up\") {\n      for (let i = 1; i < shipLength; i++) {\n        arr.push(`${arr[0][0]}${Number(number) - i}`);\n      }\n    }\n    if (direction === \"down\") {\n      for (let i = 1; i < shipLength; i++) {\n        arr.push(`${arr[0][0]}${Number(number) + i}`);\n      }\n    }\n    if (direction === \"left\") {\n      for (let i = 1; i < shipLength; i++) {\n        arr.push(\n          `${String.fromCharCode(arr[0][0].charCodeAt(0) - i)}${number}`\n        );\n      }\n    }\n    if (direction === \"right\") {\n      for (let i = 1; i < shipLength; i++) {\n        arr.push(\n          `${String.fromCharCode(arr[0][0].charCodeAt(0) + i)}${number}`\n        );\n      }\n    }\n    return arr;\n  };\n\n  // method to generate ship position based on current condition of map cells\n  const generateShip = (ship: any, obj: any) => {\n    // generate first cell of first ship\n    let firstCell = generateStartingPoint(obj);\n    let shipPosition = [];\n    shipPosition.push(firstCell);\n    // if it's not 1cell ship make sure that you can turn ship somewhere\n    if (ship[0] !== \"v\") {\n      let shipPossibleDirections = whereTurnShip(\n        obj,\n        ship,\n        firstCell,\n        direction\n      );\n      while (shipPossibleDirections.length === 0) {\n        firstCell = generateStartingPoint(obj);\n        shipPossibleDirections = whereTurnShip(obj, ship, firstCell, direction);\n      }\n      shipPosition[0] = firstCell;\n      // choose random direction of ship based on possible directions\n      const shipDirection =\n        shipPossibleDirections[\n          Math.floor(Math.random() * shipPossibleDirections.length)\n        ];\n      // add rest of ship coordinates to array to have full shape of ship\n      shipPosition = fillShipArray(ship, shipPosition, shipDirection);\n    }\n    return shipPosition;\n  };\n\n  // method to generate complete computer map of ships\n  const generateComputerMap = () => {\n    // object to storage ships positions\n    const ships = generateFreeCells({});\n    // object to storage ships positions with ships shadows\n    const shipsShadows = generateFreeCells({});\n    shipNames.forEach((ship) => {\n      const shipPosition = generateShip(ship, shipsShadows);\n      setShip(\"computer\", ship, shipPosition);\n      setShipsStatus(\"computer\", ship, true);\n      const shipPositionWithArrays = fillShipArrayWithShadows(shipPosition);\n      shipPosition.forEach((pos: any) => (ships[pos] = false));\n      shipPositionWithArrays.forEach((pos: any) => (shipsShadows[pos] = false));\n    });\n    // pass objects with information to corresponding reducers\n    setShipsCellsTotal(ships);\n    setShipsShadowsCellsTotal(\"computer\", shipsShadows);\n  };\n\n  // method to generate random computer attempt considering is this cell occupied with previous random or with shadow of guessed ship\n  const generateComputerAttempt = () => {\n    let currentAttempt = randomPosition();\n    while (\n      computer.wrongAttempts[currentAttempt] ||\n      !player.shipsShadowsCells[currentAttempt]\n    )\n      currentAttempt = randomPosition();\n    return currentAttempt;\n  };\n\n  // method how computer is going to guess next player ship cell based on\n  // quantity of already guessed cells\n  const guessNextPlayerShipCell = (ship: any) =>\n    ship.length === 1\n      ? guessBasedOnOneCell(ship[0])\n      : guessBasedOnTwoCells(ship);\n\n  // method to add cells to damaged ship\n  const addCellToDamagedShip = (cell: any) => {\n    const { damagedShip } = player;\n    if (damagedShip.length === 0) {\n      setDamagedShip([cell]);\n    } else {\n      const direction = determineShipDirection(damagedShip[0], cell);\n      const damagedShipCopy = damagedShip;\n      let necessaryIndex;\n      if (direction === \"vertical\")\n        necessaryIndex = damagedShip.findIndex(\n          (currentCell: any) =>\n            Number(considerCellNumber(cell)) <\n            Number(considerCellNumber(currentCell))\n        );\n      if (direction === \"horizontal\")\n        necessaryIndex = damagedShip.findIndex(\n          (currentCell: any) => cell.charCodeAt(0) < currentCell.charCodeAt(0)\n        );\n      if (necessaryIndex === -1) necessaryIndex = damagedShip.length;\n      damagedShipCopy.splice(necessaryIndex, 0, cell);\n      setDamagedShip(damagedShipCopy);\n    }\n  };\n\n  // method to determine ship direction based on ship coordinates\n  const determineShipDirection = (firstCell: any, lastCell: any) => {\n    return firstCell[0] === lastCell[0] ? \"vertical\" : \"horizontal\";\n  };\n\n  // method for computer attempt after player attempt\n  const checkComputerAttempt = () => {\n    const { damagedShip } = player;\n    const currentAttempt =\n      damagedShip.length === 0\n        ? generateComputerAttempt()\n        : guessNextPlayerShipCell(damagedShip);\n    setWrongAttempts(\"computer\", currentAttempt);\n    setAttempts(\"computer\");\n    setLegendLineOne(`Now is computer's turn. Attempt is: ${currentAttempt}`);\n    // check if ship was damaged or not\n    if (!player.shipsCells[currentAttempt]) {\n      // if ship was damaged\n      setLegendLineTwo(`Computer catched some of your ships`);\n      setKilledCells(\"player\", currentAttempt);\n      const damagedShipName: any = whatTheShip(\"player\", currentAttempt);\n      removeCellFromShip(\"player\", currentAttempt);\n      // check if ship was completely destroyed or not\n      if (isShipDestroyed(\"player\", damagedShipName)) {\n        // if completely destroyed we just looking for new random cell\n        const destroyedShipShadows = fillShipArrayWithShadows([\n          ...damagedShip,\n          currentAttempt,\n        ]);\n        const playerShipsShadowsCellsCopy = player.shipsShadowsCells;\n        destroyedShipShadows.forEach(\n          (cell: any) => (playerShipsShadowsCellsCopy[cell] = false)\n        );\n        setShipsShadowsCellsTotal(\"player\", playerShipsShadowsCellsCopy);\n        setDamagedShip([]);\n        if (damagedShipName[0] === \"v\")\n          setTimeout(() => checkComputerAttempt(), 2000);\n      } else {\n        addCellToDamagedShip(currentAttempt);\n      }\n    } else {\n      setLegendLineTwo(\"Computer missed all of your ships\");\n    }\n  };\n\n  // method to provide random neighbour cell based on one cell\n  const guessBasedOnOneCell = (cell: any) => {\n    // we need to filter array of cells to make sure that we not tried this cell before and it's not lying on other ship shadow\n    const neighbourCells = createNeighbourCellsArray(cell, false);\n    const filteredneighbourCells = neighbourCells.filter(\n      (cell) => !computer.wrongAttempts[cell] && player.shipsShadowsCells[cell]\n    );\n    // take random cell from filtered array\n    let randomNeigbourCell =\n      filteredneighbourCells[\n        Math.floor(Math.random() * filteredneighbourCells.length)\n      ];\n    return randomNeigbourCell;\n  };\n\n  // guessing next player cell if we have 2 cells of damaged ship\n  const guessBasedOnTwoCells = (ship: any) => {\n    const direction = determineShipDirection(ship[0], ship[ship.length - 1]);\n    const neighbourCells = [];\n    if (direction === \"vertical\") {\n      neighbourCells.push(\n        `${ship[0][0]}${Number(considerCellNumber(ship[0])) - 1}`\n      );\n      neighbourCells.push(\n        `${ship[0][0]}${Number(considerCellNumber(ship[ship.length - 1])) + 1}`\n      );\n    }\n    if (direction === \"horizontal\") {\n      const thisCellNumber = considerCellNumber(ship[0]);\n      neighbourCells.push(\n        `${String.fromCharCode(ship[0].charCodeAt(0) - 1)}${thisCellNumber}`\n      );\n    }\n    const filteredneighbourCells = neighbourCells.filter(\n      (cell) => !computer.wrongAttempts[cell] && player.shipsShadowsCells[cell]\n    );\n    return filteredneighbourCells.length === 1\n      ? filteredneighbourCells[0]\n      : filteredneighbourCells[\n          Math.floor(Math.random() * filteredneighbourCells.length)\n        ];\n  };\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  // methods for player playing\n\n  useEffect(() => {\n    console.log(\"player possibleDirections\", player.possibleDirections);\n  }, [player.possibleDirections]);\n\n  useEffect(() => {\n    console.log(\"player shipsCells\", player.shipsCells);\n  }, [player.shipsCells]);\n\n  useEffect(() => {\n    console.log(\"player shipsShadowCells\", player.shipsShadowCells);\n  }, [player.shipsShadowCells]);\n\n  // method to place player's ship on map\n  const placePlayerShipOnMap = (cellNumber: any) => {\n    shipNames.forEach((ship, index) => {\n      // check if cell is not occupied already\n      if (player.shipsCells[cellNumber]) {\n        if (\n          (index === 0 && player[ship]?.length < shipLengths[index]) ||\n          (index > 0 &&\n            player[shipNames[index - 1]]?.length === shipLengths[index - 1] &&\n            player[ship]?.length < shipLengths[index])\n        ) {\n          setShip(\"player\", shipNames[index], [cellNumber]);\n          setShipsCells(\"player\", cellNumber);\n          if (player[ship]?.length === shipLengths[index] - 1) {\n            const currentShipShadow = fillShipArrayWithShadows([\n              ...player[ship],\n              cellNumber,\n            ]);\n            currentShipShadow.forEach((cell) =>\n              setShipsShadowsCells(\"player\", cell)\n            );\n          }\n          if (player[ship]?.length === 0 && index < 6) {\n            const directions = whereTurnShip(\n              player.shipsShadowsCells,\n              ship,\n              cellNumber,\n              direction\n            );\n            directions.forEach((dir) =>\n              fillPossibleDirection(ship, [cellNumber], dir)\n            );\n          }\n          if (player[ship]?.length === 1 && index < 6) {\n            removePossibleDirections();\n            const dir = determineDirection(player[ship][0], cellNumber);\n            fillPossibleDirection(ship, [player[ship][0]], dir);\n          }\n        }\n      }\n    });\n  };\n\n  // method to check was attempt wrong or not\n  const checkPlayerAttempt = (value: any) => {\n    const correctedValue = value.toLowerCase();\n    setLegendLineTwo(\"\");\n    setAttempts(\"player\");\n    if (player.wrongAttempts[value]) {\n      setLegendLineOne(\"You already tried this cell\");\n      setLegendLineTwo(\"Please provide cell from existing range of cells\");\n    } else if (computer.shipsCells[correctedValue] === undefined) {\n      setLegendLineOne(\"Provided cell doesn't exist\");\n      setLegendLineTwo(\"Please provide cell from existing range of cells\");\n    } else {\n      setWrongAttempts(\"player\", correctedValue);\n      if (!computer.shipsCells[correctedValue]) {\n        setLegendLineOne(\"Nice job. You catch the ship\");\n        setLegendLineTwo(\"You have one more try to catch enemy ship\");\n        setKilledCells(\"computer\", correctedValue);\n        removeCellFromShip(\"computer\", correctedValue);\n      } else {\n        setLegendLineOne(\"You missed any of ships\");\n        setLegendLineTwo(\"\");\n        setTimeout(() => {\n          checkComputerAttempt();\n        }, 2000);\n      }\n    }\n  };\n\n  // method to fill possible directions\n  const fillPossibleDirection = (ship: any, cell: any, direction: any) => {\n    const shipPosition = fillShipArray(ship, cell, direction);\n    shipPosition.forEach((shipCell: any, cellIndex: any) => {\n      if (cellIndex > 0) setPossibleDirections(shipCell);\n    });\n  };\n\n  // method to determine ship direction based on started and second points\n  const determineDirection = (cellFirst: any, cellSecond: any) => {\n    const cellFirstNumber = considerCellNumber(cellFirst);\n    const cellSecondNumber = considerCellNumber(cellSecond);\n    return cellFirst[0] === cellSecond[0]\n      ? Number(cellFirstNumber) > Number(cellSecondNumber)\n        ? \"up\"\n        : \"down\"\n      : String.fromCharCode(cellFirst[0].charCodeAt(0) - 1) === cellSecond[0]\n      ? \"left\"\n      : \"right\";\n  };\n\n  // method to draw possible directions of ship once start position is determined\n  // right now only provides information in legend\n  const drawPossibleDirections = () => {\n    shipNames.forEach((ship, index) => {\n      if (player[ship]?.length === shipLengths[index]) {\n        if (index < shipNames.length - 1) {\n          setLegendLineOne(\n            strings.battle.completed.replace(\"{}\", shipNicknames[index])\n          );\n          setLegendLineTwo(\n            strings.battle.proposition.replace(\"{}\", shipNicknames[index + 1])\n          );\n        } else {\n          setLegendLineOne(strings.battle.placementCompleted);\n          setLegendLineTwo(\"\");\n        }\n        setShipsStatus(\"player\", ship, true);\n      }\n    });\n  };\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  // front-end methods\n\n  const killPlayer = () => {\n    shipNames.forEach((ship) => setShipsStatus(\"player\", ship, false));\n    setFirstTime(false);\n    setOpen(true);\n  };\n\n  const killComputer = () => {\n    shipNames.forEach((ship) => setShipsStatus(\"computer\", ship, false));\n    setFirstTime(false);\n    setOpen(true);\n  };\n\n  const shipsCondition = (side: any) => {\n    const condition = (ship: any, index: any) => {\n      let response = \"\";\n      if (side[ship].length === shipLengths[index]) response = \"undamaged\";\n      else if (side[ship].length === 0) response = \"destroyed\";\n      else response = \"damaged\";\n      return response;\n    };\n\n    return (\n      <React.Fragment>\n        {shipNicknames.map((ship, index) => {\n          return (\n            <Typography\n              key={`shipsCondition${ship}${index}`}\n              variant=\"subtitle2\"\n            >{`${index + 1}.${ship}: ${condition(\n              shipNames[index],\n              index\n            )}`}</Typography>\n          );\n        })}\n      </React.Fragment>\n    );\n  };\n\n  return (\n    <Fragment>\n      <Grid\n        container\n        style={{ marginBottom: 20 }}\n        direction=\"column\"\n        alignItems=\"center\"\n      >\n        <Typography style={{ color: \"white\" }} variant=\"h5\">\n          Score:\n        </Typography>\n        <Typography style={{ color: \"white\" }} variant=\"h5\">\n          {score[0]}:{score[1]}\n        </Typography>\n        {playAgain && !firstTime ? (\n          <Modal\n            open={open}\n            onClose={() => {\n              setOpen(false);\n            }}\n            aria-labelledby=\"simple-modal-title\"\n            aria-describedby=\"simple-modal-description\"\n            style={{\n              display: \"flex\",\n              alignItems: \"center\",\n              justifyContent: \"center\",\n            }}\n          >\n            <PlayAgain oneMoreGame={oneMoreTimeGame} />\n          </Modal>\n        ) : null}\n      </Grid>\n      <Grid\n        container\n        direction=\"row\"\n        spacing={5}\n        justify=\"center\"\n        style={{ backgroundColor: \"white\" }}\n      >\n        <Grid item>\n          <Grid container direction=\"column\" alignItems=\"center\">\n            <Typography variant=\"h4\">{playerName}</Typography>\n            <Field side={\"player\"} placeShipOnMap={placePlayerShipOnMap} />\n            {isBattle ? (\n              <React.Fragment>\n                <Grid item style={{ marginTop: 20 }}>\n                  <Grid container direction=\"row\" spacing={2} justify=\"center\">\n                    <Grid item>\n                      <TextField\n                        variant=\"outlined\"\n                        style={{ width: 70, height: 10 }}\n                        onChange={(event) =>\n                          setPlayerAttempt(event.target.value)\n                        }\n                        onKeyDown={(e) => {\n                          if (e.keyCode === 13)\n                            checkPlayerAttempt(playerAttempt);\n                        }}\n                      />\n                    </Grid>\n                    <Grid item style={{ marginTop: 10 }}>\n                      <Button\n                        variant=\"contained\"\n                        color=\"primary\"\n                        onClick={() => checkPlayerAttempt(playerAttempt)}\n                      >\n                        Enter cell\n                      </Button>\n                    </Grid>\n                  </Grid>\n                  <Typography\n                    style={{ marginTop: 20 }}\n                    variant=\"h6\"\n                  >{`Quantity of your attempts: ${player.attempts}`}</Typography>\n                </Grid>\n                <Grid item style={{ marginTop: 20 }}>\n                  {shipsCondition(player)}\n                </Grid>\n              </React.Fragment>\n            ) : null}\n            <Grid item>\n              <Button\n                variant=\"contained\"\n                color=\"primary\"\n                onClick={killPlayer}\n                style={{ marginTop: 20 }}\n              >\n                Kill player\n              </Button>\n            </Grid>\n          </Grid>\n        </Grid>\n        <Grid item>\n          <Grid container direction=\"column\" alignItems=\"center\">\n            <Typography variant=\"h4\">computer</Typography>\n            <Field\n              side={\"computer\"}\n              placeShipOnMap={placePlayerShipOnMap}\n            />{\" \"}\n            <Grid item>\n              <Button\n                variant=\"contained\"\n                color=\"primary\"\n                onClick={killComputer}\n                style={{ marginTop: 20 }}\n              >\n                Kill computer\n              </Button>\n            </Grid>\n            <Grid item>\n              <Button\n                variant=\"contained\"\n                color=\"primary\"\n                style={{ marginTop: 20 }}\n                onClick={setShowComputer}\n              >\n                {showComputer ? \"Hide Ships\" : \"Show Ships\"}\n              </Button>\n            </Grid>\n          </Grid>\n          <Typography\n            style={{ marginTop: 20 }}\n            variant=\"h6\"\n          >{`Quantity of computer attempts: ${computer.attempts}`}</Typography>\n          <Grid item>{shipsCondition(computer)}</Grid>\n        </Grid>\n      </Grid>\n    </Fragment>\n  );\n};\n\nconst mapStateToProps = (state: any) => {\n  const {\n    player,\n    computer,\n    showComputer,\n    playAgain,\n    firstTime,\n    isBattle,\n    score,\n    playerName,\n  } = state;\n  return {\n    player,\n    computer,\n    showComputer,\n    playAgain,\n    firstTime,\n    isBattle,\n    score,\n    playerName,\n  };\n};\n\nconst mapDispatchToProps = (dispatch: any) => ({\n  setShip: (player: any, ship: any, position: any) =>\n    dispatch(setShip(player, ship, position)),\n  setShipsCells: (player: any, cell: any) =>\n    dispatch(setShipsCells(player, cell)),\n  setShipsShadowsCells: (player: any, cell: any) =>\n    dispatch(setShipsShadowsCells(player, cell)),\n  setLegendLineTwo: (legend: string) => dispatch(setLegendLineTwo(legend)),\n  setLegendLineOne: (legend: string) => dispatch(setLegendLineOne(legend)),\n  setShowComputer: () => dispatch(setShowComputer()),\n  setShipsStatus: (player: any, ship: any, status: any) =>\n    dispatch(setShipsStatus(player, ship, status)),\n  setKilledCells: (player: any, cell: any) =>\n    dispatch(setKilledCells(player, cell)),\n  removeShipCell: (player: any, ship: any, cell: any) =>\n    dispatch(removeShipCell(player, ship, cell)),\n  setWrongAttempts: (player: any, attempt: any) =>\n    dispatch(setWrongAttempts(player, attempt)),\n  setPossibleDirections: (cell: any) => dispatch(setPossibleDirections(cell)),\n  removePossibleDirections: () => dispatch(removePossibleDirections()),\n  setAttempts: (player: any) => dispatch(setAttempts(player)),\n  setShipsCellsTotal: (obj: any) => dispatch(setShipsCellsTotal(obj)),\n  setShipsShadowsCellsTotal: (player: any, obj: any) =>\n    dispatch(setShipsShadowsCellsTotal(player, obj)),\n  removeShadows: () => dispatch(removeShadows()),\n  setPlayAgain: (status: any) => dispatch(setPlayAgain(status)),\n  setFirstTime: (status: any) => dispatch(setFirstTime(status)),\n  clearEverything: () => dispatch(clearEverything()),\n  setDamagedShip: (ship: any) => dispatch(setDamagedShip(ship)),\n  setIsBattle: (status: any) => dispatch(setIsBattle(status)),\n  setScore: (side: any) => dispatch(setScore(side)),\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Battle);\n","/home/averemyeyev/andriy/projects/battleship/src/StartGame.tsx",[],"/home/averemyeyev/andriy/projects/battleship/src/strings.ts",[],"/home/averemyeyev/andriy/projects/battleship/src/actions/index.ts",[],"/home/averemyeyev/andriy/projects/battleship/src/EnterName.tsx",[],"/home/averemyeyev/andriy/projects/battleship/src/Field.tsx",[],["69","70"],"/home/averemyeyev/andriy/projects/battleship/src/PlayAgain.tsx",[],{"ruleId":"71","replacedBy":"72"},{"ruleId":"73","replacedBy":"74"},{"ruleId":"75","severity":1,"message":"76","line":123,"column":6,"nodeType":"77","endLine":123,"endColumn":8,"suggestions":"78"},{"ruleId":"75","severity":1,"message":"79","line":128,"column":6,"nodeType":"77","endLine":128,"endColumn":25,"suggestions":"80"},{"ruleId":"75","severity":1,"message":"81","line":148,"column":6,"nodeType":"77","endLine":148,"endColumn":57,"suggestions":"82"},{"ruleId":"75","severity":1,"message":"83","line":160,"column":6,"nodeType":"77","endLine":160,"endColumn":39,"suggestions":"84"},{"ruleId":"75","severity":1,"message":"85","line":164,"column":6,"nodeType":"77","endLine":164,"endColumn":25,"suggestions":"86"},{"ruleId":"75","severity":1,"message":"87","line":172,"column":6,"nodeType":"77","endLine":172,"endColumn":33,"suggestions":"88"},{"ruleId":"71","replacedBy":"89"},{"ruleId":"73","replacedBy":"90"},"no-native-reassign",["91"],"no-negated-in-lhs",["92"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'generateComputerMap'. Either include it or remove the dependency array.","ArrayExpression",["93"],"React Hook useEffect has a missing dependency: 'drawPossibleDirections'. Either include it or remove the dependency array.",["94"],"React Hook useEffect has missing dependencies: 'removeShadows', 'setIsBattle', 'setLegendLineOne', 'setLegendLineTwo', 'setPlayAgain', and 'setScore'. Either include them or remove the dependency array.",["95"],"React Hook useEffect has missing dependencies: 'setLegendLineOne', 'setLegendLineTwo', 'setPlayAgain', and 'setScore'. Either include them or remove the dependency array.",["96"],"React Hook useEffect has a missing dependency: 'setFirstTime'. Either include it or remove the dependency array.",["97"],"React Hook useEffect has missing dependencies: 'checkComputerAttempt' and 'firstRender'. Either include them or remove the dependency array.",["98"],["91"],["92"],"no-global-assign","no-unsafe-negation",{"desc":"99","fix":"100"},{"desc":"101","fix":"102"},{"desc":"103","fix":"104"},{"desc":"105","fix":"106"},{"desc":"107","fix":"108"},{"desc":"109","fix":"110"},"Update the dependencies array to be: [generateComputerMap]",{"range":"111","text":"112"},"Update the dependencies array to be: [drawPossibleDirections, player.shipsCells]",{"range":"113","text":"114"},"Update the dependencies array to be: [player.shipsStatus, firstTime, player.damagedShip, removeShadows, setIsBattle, setLegendLineOne, setLegendLineTwo, setPlayAgain, setScore]",{"range":"115","text":"116"},"Update the dependencies array to be: [computer.shipsStatus, firstTime, setLegendLineOne, setLegendLineTwo, setPlayAgain, setScore]",{"range":"117","text":"118"},"Update the dependencies array to be: [player.battleShip, setFirstTime]",{"range":"119","text":"120"},"Update the dependencies array to be: [checkComputerAttempt, firstRender, player.damagedShip.length]",{"range":"121","text":"122"},[2587,2589],"[generateComputerMap]",[2675,2694],"[drawPossibleDirections, player.shipsCells]",[3216,3267],"[player.shipsStatus, firstTime, player.damagedShip, removeShadows, setIsBattle, setLegendLineOne, setLegendLineTwo, setPlayAgain, setScore]",[3551,3584],"[computer.shipsStatus, firstTime, setLegendLineOne, setLegendLineTwo, setPlayAgain, setScore]",[3674,3693],"[player.battleShip, setFirstTime]",[3864,3891],"[checkComputerAttempt, firstRender, player.damagedShip.length]"]